/*
 * Copyright 2024 Readium Foundation. All rights reserved.
 * Use of this source code is governed by the BSD-style license
 * available in the top-level LICENSE file of the project.
 */

/*
 * Copyright 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import androidx.annotation.FloatRange
import androidx.compose.animation.core.AnimationSpec
import androidx.compose.animation.core.DecayAnimationSpec
import androidx.compose.animation.core.Spring
import androidx.compose.animation.core.VisibilityThreshold
import androidx.compose.animation.core.spring
import androidx.compose.animation.rememberSplineBasedDecay
import androidx.compose.foundation.gestures.FlingBehavior
import androidx.compose.foundation.gestures.Orientation
import androidx.compose.foundation.gestures.TargetedFlingBehavior
import androidx.compose.foundation.pager.PagerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.unit.Density
import org.readium.navigator.web.snapping.PagingLayoutInfo
import org.readium.navigator.web.snapping.SnapLayoutInfoProvider
import org.readium.navigator.web.snapping.calculateFinalSnappingBound
import org.readium.navigator.web.snapping.snapFlingBehavior
import org.readium.navigator.web.webview.DefaultPositionThreshold

/**
 * A [snapFlingBehavior] that will snap pages to the start of the layout. One can use the
 * given parameters to control how the snapping animation will happen.
 * @see androidx.compose.foundation.gestures.snapping.snapFlingBehavior for more information
 * on what which parameter controls in the overall snapping animation.
 *
 * The animation specs used by the fling behavior will depend on 2 factors:
 * 1) The gesture velocity.
 * 2) The target page proposed by [pagerSnapDistance].
 *
 * If you're using single page snapping (the most common use case for [Pager]), there won't
 * be enough space to actually run a decay animation to approach the target page, so the Pager
 * will always use the snapping animation from [snapAnimationSpec].
 * If you're using multi-page snapping (this means you're abs(targetPage - currentPage) > 1)
 * the Pager may use [decayAnimationSpec] or [snapAnimationSpec] to approach the
 * targetPage, it will depend on the velocity generated by the triggering gesture.
 * If the gesture has a high enough velocity to approach the target page, the Pager will use
 * [decayAnimationSpec] followed by [snapAnimationSpec] for the final step of the
 * animation. If the gesture doesn't have enough velocity, the Pager will use
 * [snapAnimationSpec] + [snapAnimationSpec] in a similar fashion.
 *
 * @param state The [PagerState] that controls the which to which this FlingBehavior will
 * be applied to.
 * @param pagerSnapDistance A way to control the snapping destination for this [Pager].
 * The default behavior will result in any fling going to the next page in the direction of the
 * fling (if the fling has enough velocity, otherwise  the Pager will bounce back). Use
 * [PagerSnapDistance.atMost] to define a maximum number of pages this [Pager] is allowed to
 * fling after scrolling is finished and fling has started.
 * @param decayAnimationSpec The animation spec used to approach the target offset. When
 * the fling velocity is large enough. Large enough means large enough to naturally decay. For
 * single page snapping this usually never happens since there won't be enough space to run a
 * decay animation.
 * @param snapAnimationSpec The animation spec used to finally snap to the position. This
 * animation will be often used in 2 cases: 1) There was enough space to an approach animation,
 * the Pager will use [snapAnimationSpec] in the last step of the animation to settle the page
 * into position. 2) There was not enough space to run the approach animation.
 * @param snapPositionalThreshold If the fling has a low velocity (e.g. slow scroll),
 * this fling behavior will use this snap threshold in order to determine if the pager should
 * snap back or move forward. Use a number between 0 and 1 as a fraction of the page size that
 * needs to be scrolled before the Pager considers it should move to the next page.
 * For instance, if snapPositionalThreshold = 0.35, it means if this pager is scrolled with a
 * slow velocity and the Pager scrolls more than 35% of the page size, then will jump to the
 * next page, if not it scrolls back.
 * Note that any fling that has high enough velocity will *always* move to the next page
 * in the direction of the fling.
 *
 * @return An instance of [FlingBehavior] that will perform Snapping to the next page by
 * default. The animation will be governed by the post scroll velocity and the Pager will use
 * either
 * [snapAnimationSpec] or [decayAnimationSpec] to approach the snapped position
 * If a velocity is not high enough the pager will use [snapAnimationSpec] to reach the snapped
 * position. If the velocity is high enough, the Pager will use the logic described in
 * [decayAnimationSpec] and [snapAnimationSpec].
 */
@Composable
internal fun pagingFlingBehavior(
    state: PagingLayoutInfo,
    decayAnimationSpec: DecayAnimationSpec<Float> = rememberSplineBasedDecay(),
    snapAnimationSpec: AnimationSpec<Float> = spring(
        stiffness = Spring.StiffnessMediumLow,
        visibilityThreshold = Int.VisibilityThreshold.toFloat()
    ),
    @FloatRange(from = 0.0, to = 1.0) snapPositionalThreshold: Float = 0.5f,
): TargetedFlingBehavior {
    require(snapPositionalThreshold in 0f..1f) {
        "snapPositionalThreshold should be a number between 0 and 1. " +
            "You've specified $snapPositionalThreshold"
    }

    val density = LocalDensity.current
    val layoutDirection = LocalLayoutDirection.current
    return remember(
        state,
        decayAnimationSpec,
        snapAnimationSpec,
        density,
        layoutDirection
    ) {
        val snapLayoutInfoProvider =
            SnapLayoutInfoProvider(
                state,
            ) { flingVelocity, lowerBound, upperBound ->
                calculateFinalSnappingBound(
                    pagingLayoutInfo = state,
                    layoutDirection = layoutDirection,
                    snapPositionalThreshold = snapPositionalThreshold,
                    flingVelocity = flingVelocity,
                    lowerBoundOffset = lowerBound,
                    upperBoundOffset = upperBound
                )
            }
        snapFlingBehavior(
            snapLayoutInfoProvider = snapLayoutInfoProvider,
            decayAnimationSpec = decayAnimationSpec,
            snapAnimationSpec = snapAnimationSpec
        )
    }
}

/**
 * A [snapFlingBehavior] that will snap pages to the start of the layout. One can use the
 * given parameters to control how the snapping animation will happen.
 * @see androidx.compose.foundation.gestures.snapping.snapFlingBehavior for more information
 * on what which parameter controls in the overall snapping animation.
 *
 * The animation specs used by the fling behavior will depend on 2 factors:
 * 1) The gesture velocity.
 * 2) The target page proposed by [pagerSnapDistance].
 *
 * If you're using single page snapping (the most common use case for [Pager]), there won't
 * be enough space to actually run a decay animation to approach the target page, so the Pager
 * will always use the snapping animation from [snapAnimationSpec].
 * If you're using multi-page snapping (this means you're abs(targetPage - currentPage) > 1)
 * the Pager may use [decayAnimationSpec] or [snapAnimationSpec] to approach the
 * targetPage, it will depend on the velocity generated by the triggering gesture.
 * If the gesture has a high enough velocity to approach the target page, the Pager will use
 * [decayAnimationSpec] followed by [snapAnimationSpec] for the final step of the
 * animation. If the gesture doesn't have enough velocity, the Pager will use
 * [snapAnimationSpec] + [snapAnimationSpec] in a similar fashion.
 *
 * @param state The [PagerState] that controls the which to which this FlingBehavior will
 * be applied to.
 * @param pagerSnapDistance A way to control the snapping destination for this [Pager].
 * The default behavior will result in any fling going to the next page in the direction of the
 * fling (if the fling has enough velocity, otherwise  the Pager will bounce back). Use
 * [PagerSnapDistance.atMost] to define a maximum number of pages this [Pager] is allowed to
 * fling after scrolling is finished and fling has started.
 * @param decayAnimationSpec The animation spec used to approach the target offset. When
 * the fling velocity is large enough. Large enough means large enough to naturally decay. For
 * single page snapping this usually never happens since there won't be enough space to run a
 * decay animation.
 * @param snapAnimationSpec The animation spec used to finally snap to the position. This
 * animation will be often used in 2 cases: 1) There was enough space to an approach animation,
 * the Pager will use [snapAnimationSpec] in the last step of the animation to settle the page
 * into position. 2) There was not enough space to run the approach animation.
 * @param snapPositionalThreshold If the fling has a low velocity (e.g. slow scroll),
 * this fling behavior will use this snap threshold in order to determine if the pager should
 * snap back or move forward. Use a number between 0 and 1 as a fraction of the page size that
 * needs to be scrolled before the Pager considers it should move to the next page.
 * For instance, if snapPositionalThreshold = 0.35, it means if this pager is scrolled with a
 * slow velocity and the Pager scrolls more than 35% of the page size, then will jump to the
 * next page, if not it scrolls back.
 * Note that any fling that has high enough velocity will *always* move to the next page
 * in the direction of the fling.
 *
 * @return An instance of [FlingBehavior] that will perform Snapping to the next page by
 * default. The animation will be governed by the post scroll velocity and the Pager will use
 * either
 * [snapAnimationSpec] or [decayAnimationSpec] to approach the snapped position
 * If a velocity is not high enough the pager will use [snapAnimationSpec] to reach the snapped
 * position. If the velocity is high enough, the Pager will use the logic described in
 * [decayAnimationSpec] and [snapAnimationSpec].
 */
@Composable
internal fun pagingFlingBehavior(
    state: PagerState,
    decayAnimationSpec: DecayAnimationSpec<Float> = rememberSplineBasedDecay(),
    snapAnimationSpec: AnimationSpec<Float> = spring(
        stiffness = Spring.StiffnessMediumLow,
        visibilityThreshold = Int.VisibilityThreshold.toFloat()
    ),
    @FloatRange(from = 0.0, to = 1.0) snapPositionalThreshold: Float = 0.5f,
): TargetedFlingBehavior {
    require(snapPositionalThreshold in 0f..1f) {
        "snapPositionalThreshold should be a number between 0 and 1. " +
            "You've specified $snapPositionalThreshold"
    }

    val density = LocalDensity.current
    val layoutDirection = LocalLayoutDirection.current
    return remember(
        state,
        decayAnimationSpec,
        snapAnimationSpec,
        density,
        layoutDirection
    ) {
        val pagingLayoutInfoAdapter = object : PagingLayoutInfo {

            override val orientation: Orientation
                get() = state.layoutInfo.orientation

            override val density: Density
                get() = density

            override val positionThresholdFraction: Float
                get() = with(density) {
                    val minThreshold = minOf(DefaultPositionThreshold.toPx(), pageSize / 2f)
                    minThreshold / pageSize.toFloat()
                }

            override val pageSize: Int
                get() = state.layoutInfo.pageSize

            override val pageSpacing: Int
                get() = state.layoutInfo.pageSpacing

            override val upDownDifference: Offset
                get() = Offset.Zero

            val firstVisiblePage: Int
                get() = state.layoutInfo.visiblePagesInfo.first().offset

            override val reverseLayout: Boolean
                get() = state.layoutInfo.reverseLayout

            override val visiblePageOffsets: List<Int>
                get() = state.layoutInfo.visiblePagesInfo.map { it.offset }

            override val canScrollForward: Boolean
                get() = state.canScrollForward

            override val canScrollBackward: Boolean
                get() = state.canScrollBackward
        }

        val snapLayoutInfoProvider =
            SnapLayoutInfoProvider(
                pagingLayoutInfoAdapter,
            ) { flingVelocity, lowerBound, upperBound ->
                calculateFinalSnappingBound(
                    pagingLayoutInfo = pagingLayoutInfoAdapter,
                    layoutDirection = layoutDirection,
                    snapPositionalThreshold = snapPositionalThreshold,
                    flingVelocity = flingVelocity,
                    lowerBoundOffset = lowerBound,
                    upperBoundOffset = upperBound
                )
            }

        snapFlingBehavior(
            snapLayoutInfoProvider = snapLayoutInfoProvider,
            decayAnimationSpec = decayAnimationSpec,
            snapAnimationSpec = snapAnimationSpec
        )
    }
}

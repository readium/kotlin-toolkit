{"version":3,"file":"fixed-injectable-script.js","mappings":"yBAWA,MAAMA,EAAiB,IAAIC,eAC3BC,OAAOC,OAAOC,YAAY,OAAQ,IAAK,CAACJ,EAAeK,QACvD,MAAMC,EAAgB,ICbf,MACH,WAAAC,CAAYC,GACRC,KAAKD,YAAcA,CACvB,CACA,IAAAE,CAAKC,GACDF,KAAKD,YAAYJ,YAAYO,EACjC,GDO0CX,EAAeY,OACvDC,EAmBN,SAA0BC,GACtB,MAAMC,EApB4Bb,OAAOY,SAoBfE,cAAc,uBACxC,GAAKD,GAAcA,aAAoBE,gBAGvC,OEJG,SAA6BC,GAChC,MAAMC,EAAQ,uBACRC,EAAa,IAAIC,IACvB,IAAIC,EACJ,KAAQA,EAAQH,EAAMI,KAAKL,IACV,MAATI,GACAF,EAAWI,IAAIF,EAAM,GAAIA,EAAM,IAGvC,MAAMG,EAAQC,WAAWN,EAAWO,IAAI,UAClCC,EAASF,WAAWN,EAAWO,IAAI,WACzC,OAAIF,GAASG,EACF,CAAEH,QAAOG,eAGhB,CAER,CFbWC,CAAoBd,EAASe,QACxC,CAzBqBC,GACrBzB,EAAcI,KAAK,CAAEsB,KAAM,cAAeC,KAAMpB,IAgBhD,MAAMqB,EAAoB,IAf1B,MACI,WAAA3B,CAAYD,GACRG,KAAKH,cAAgBA,CACzB,CACA,KAAA6B,CAAMC,GACF3B,KAAKH,cAAcI,KAAK,CAAEsB,KAAM,MAAOK,EAAGD,EAAME,QAASC,EAAGH,EAAMI,SACtE,CACA,eAAAC,CAAgBC,EAAMC,GAClBlC,KAAKH,cAAcI,KAAK,CACpBsB,KAAM,gBACNU,KAAMA,EACNC,UAAWA,GAEnB,GAEoDrC,GACxD,IGhCO,MACH,WAAAC,CAAYL,EAAQ0C,GAChBnC,KAAKP,OAASA,EACdO,KAAKmC,SAAWA,EAChB9B,SAAS+B,iBAAiB,SAAUT,IAChC3B,KAAKqC,QAAQV,EAAM,IACpB,EACP,CACA,OAAAU,CAAQV,GACJ,GAAIA,EAAMW,iBACN,OAEJ,MAAMC,EAAYvC,KAAKP,OAAO+C,eAC9B,GAAID,GAA+B,SAAlBA,EAAUE,KAIvB,OAEJ,IAAIC,EAEAA,EADAf,EAAMgB,kBAAkBC,YACP5C,KAAK6C,0BAA0BlB,EAAMgB,QAGrC,KAEjBD,EACIA,aAA0BI,mBAC1B9C,KAAKmC,SAASH,gBAAgBU,EAAeT,KAAMS,EAAeK,WAItE/C,KAAKmC,SAAST,MAAMC,GAExBA,EAAMqB,kBACNrB,EAAMsB,gBACV,CAEA,yBAAAJ,CAA0BK,GACtB,OAAe,MAAXA,EACO,MAgBqD,GAdxC,CACpB,IACA,QACA,SACA,SACA,UACA,QACA,QACA,SACA,SACA,SACA,WACA,SAEgBC,QAAQD,EAAQE,SAASC,gBAIzCH,EAAQI,aAAa,oBACoC,SAAzDJ,EAAQK,aAAa,mBAAmBF,cAJjCH,EAQPA,EAAQM,cACDxD,KAAK6C,0BAA0BK,EAAQM,eAE3C,IACX,GHrCiB/D,OAAQgC,E","sources":["webpack://readium-js/./src/index-fixed-injectable.ts","webpack://readium-js/./src/fixed/iframe-message.ts","webpack://readium-js/./src/util/viewport.ts","webpack://readium-js/./src/common/gestures.ts"],"sourcesContent":["//\n//  Copyright 2024 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n/**\n * Script loaded by fixed layout resources.\n */\nimport { GesturesDetector } from \"./common/gestures\";\nimport { IframeMessageSender } from \"./fixed/iframe-message\";\nimport { parseViewportString } from \"./util/viewport\";\nconst messageChannel = new MessageChannel();\nwindow.parent.postMessage(\"Init\", \"*\", [messageChannel.port2]);\nconst messageSender = new IframeMessageSender(messageChannel.port1);\nconst viewportSize = parseContentSize(window.document);\nmessageSender.send({ kind: \"contentSize\", size: viewportSize });\nclass MessagingGesturesListener {\n    constructor(messageSender) {\n        this.messageSender = messageSender;\n    }\n    onTap(event) {\n        this.messageSender.send({ kind: \"tap\", x: event.clientX, y: event.clientY });\n    }\n    onLinkActivated(href, outerHtml) {\n        this.messageSender.send({\n            kind: \"linkActivated\",\n            href: href,\n            outerHtml: outerHtml,\n        });\n    }\n}\nconst messagingListener = new MessagingGesturesListener(messageSender);\nnew GesturesDetector(window, messagingListener);\nfunction parseContentSize(document) {\n    const viewport = document.querySelector(\"meta[name=viewport]\");\n    if (!viewport || !(viewport instanceof HTMLMetaElement)) {\n        return undefined;\n    }\n    return parseViewportString(viewport.content);\n}\n","export class IframeMessageSender {\n    constructor(messagePort) {\n        this.messagePort = messagePort;\n    }\n    send(message) {\n        this.messagePort.postMessage(message);\n    }\n}\n","export class ViewportStringBuilder {\n    setInitialScale(scale) {\n        this.initialScale = scale;\n        return this;\n    }\n    setMinimumScale(scale) {\n        this.minimumScale = scale;\n        return this;\n    }\n    setWidth(width) {\n        this.width = width;\n        return this;\n    }\n    setHeight(height) {\n        this.height = height;\n        return this;\n    }\n    build() {\n        const components = [];\n        if (this.initialScale) {\n            components.push(\"initial-scale=\" + this.initialScale);\n        }\n        if (this.minimumScale) {\n            components.push(\"minimum-scale=\" + this.minimumScale);\n        }\n        if (this.width) {\n            components.push(\"width=\" + this.width);\n        }\n        if (this.height) {\n            components.push(\"height=\" + this.height);\n        }\n        return components.join(\", \");\n    }\n}\nexport function parseViewportString(viewportString) {\n    const regex = /(\\w+) *= *([^\\s,]+)/g;\n    const properties = new Map();\n    let match;\n    while ((match = regex.exec(viewportString))) {\n        if (match != null) {\n            properties.set(match[1], match[2]);\n        }\n    }\n    const width = parseFloat(properties.get(\"width\"));\n    const height = parseFloat(properties.get(\"height\"));\n    if (width && height) {\n        return { width, height };\n    }\n    else {\n        return undefined;\n    }\n}\n","export class GesturesDetector {\n    constructor(window, listener) {\n        this.window = window;\n        this.listener = listener;\n        document.addEventListener(\"click\", (event) => {\n            this.onClick(event);\n        }, false);\n    }\n    onClick(event) {\n        if (event.defaultPrevented) {\n            return;\n        }\n        const selection = this.window.getSelection();\n        if (selection && selection.type == \"Range\") {\n            // There's an on-going selection, the tap will dismiss it so we don't forward it.\n            // selection.type might be None (collapsed) or Caret with a collapsed range\n            // when there is not true selection.\n            return;\n        }\n        let nearestElement;\n        if (event.target instanceof HTMLElement) {\n            nearestElement = this.nearestInteractiveElement(event.target);\n        }\n        else {\n            nearestElement = null;\n        }\n        if (nearestElement) {\n            if (nearestElement instanceof HTMLAnchorElement) {\n                this.listener.onLinkActivated(nearestElement.href, nearestElement.outerHTML);\n            }\n        }\n        else {\n            this.listener.onTap(event);\n        }\n        event.stopPropagation();\n        event.preventDefault();\n    }\n    // See. https://github.com/JayPanoz/architecture/tree/touch-handling/misc/touch-handling\n    nearestInteractiveElement(element) {\n        if (element == null) {\n            return null;\n        }\n        const interactiveTags = [\n            \"a\",\n            \"audio\",\n            \"button\",\n            \"canvas\",\n            \"details\",\n            \"input\",\n            \"label\",\n            \"option\",\n            \"select\",\n            \"submit\",\n            \"textarea\",\n            \"video\",\n        ];\n        if (interactiveTags.indexOf(element.nodeName.toLowerCase()) != -1) {\n            return element;\n        }\n        // Checks whether the element is editable by the user.\n        if (element.hasAttribute(\"contenteditable\") &&\n            element.getAttribute(\"contenteditable\").toLowerCase() != \"false\") {\n            return element;\n        }\n        // Checks parents recursively because the touch might be for example on an <em> inside a <a>.\n        if (element.parentElement) {\n            return this.nearestInteractiveElement(element.parentElement);\n        }\n        return null;\n    }\n}\n"],"names":["messageChannel","MessageChannel","window","parent","postMessage","port2","messageSender","constructor","messagePort","this","send","message","port1","viewportSize","document","viewport","querySelector","HTMLMetaElement","viewportString","regex","properties","Map","match","exec","set","width","parseFloat","get","height","parseViewportString","content","parseContentSize","kind","size","messagingListener","onTap","event","x","clientX","y","clientY","onLinkActivated","href","outerHtml","listener","addEventListener","onClick","defaultPrevented","selection","getSelection","type","nearestElement","target","HTMLElement","nearestInteractiveElement","HTMLAnchorElement","outerHTML","stopPropagation","preventDefault","element","indexOf","nodeName","toLowerCase","hasAttribute","getAttribute","parentElement"],"sourceRoot":""}